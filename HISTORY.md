# History of creating this code with Cursor

## ORIGINAL PROMPT: create web app
> Create a simple PDF editor named "PDFtool" as a modern web app built using Vue.js. The app should have two features that users can choose from: 1) merge multiple PDF files together into a single file, and 2) delete one or more pages from a single PDF file. These features are presented as a list for users to choose from and also prepares for new features to be added. The user interface (UI) should have modern fonts and good contrast for human viewing, and the overall UI should be pleasant and visually-appealing.
>
> For the merge feature, users have access to a file selector dialog to choose multiple PDF files from their filesystem. There is also has a text field for users to enter the filename for the merged PDF file.
>
> The delete feature has a file selector for users to select the file they wish to edit. Once a file is selected, the app shows users all pages in the file and allows users to select the pages they want to delete. This can be a single or multiple pages. For multiple pages, users will have checkboxes for each page in the document. They should have the ability to drag-and-drop a group of pages to auto-select and check.
>
> The backend should be a short Python Flask and FastAPI app that can use the pypdf library directly or call the pdfly command-line tool (CLI) to execute user requests. Evaluate both options and implement the one that would be easiest to maintain for a human software developer and requires the least amount of code.
>
> All source code for both frontend and backend should be separate and created in the directory `~/work/cursor/pdftool`.


### Results
The app had many flaws, such as the frontend and backend services failing to start for one reason or another. After many rounds of coaxing, debugging, and fixes, I finally got a working version you find in both the `frontend` and `backend` folders. There were two big issues overall:
1. Cursor just could not generate a Vue app that worked, so I had to switch to React.
1. There were some major Tailwind v3 vs. v4 compatibility issues as well as with the PostCSS plugin. Cursor tried very hard to use v4 but in the end had to revert back to v3.


## NEXT PROMPT: design to run on GCP (Cloud Run)
> Both the merge PDFs and delete pages features work! Now containerize the application so I can deploy both services to Google Cloud Run Functions.


### Results
Cursor asked me whether it should create `Dockerfile`s & `.dockerignore` files for both the frontend and backend. I said yes, and also create a `cloudbuild.yaml` file too.

It did create both, but the 2nd `.dockerfile` ignore ran into an infinite loop adding the same set of lines. I had to tell Cursor to stop, remove the file if it exists, and to try again. It did so successfully the 2nd time then moved onto the `cloudbuild.yaml` file.

I have **not** tested whether it works, meaning I haven't deployed it to Cloud Run yet.


## NEXT PROMPT: create a CLI equivalent
> In a subfolder named "cli", convert this app to a single command-line Python script with the same features, prompting users to provide names of PDF files for merging or a single PDF filename to delete pages from.


### Results
I haven't tested the CLI either but wanted to check everything in for posterity first before any more file altering takes place.

## NEXT PROMPT: commit code to `git` and GitHub
> Run git init in the top-level folder and create a .gitignore that covers superfluous files in frontend, backend, and cli.


### Results
It ran `git init` and autogenerated a nice `.gitignore`, then running a `git status` so I could see the results. Then it generated a top-level `README` with complete project info.

I followed with a request to "Run the git commands and commit to my GitHub account." While it did the commit locally, it noticed that the repo doesn't exist on GH yet and failed there, prompting me to install the `gh` command. Cursor then gave me a command of `gh repo create wescpy/pdftool --public --source=. --remote=origin --push` to create this very repo you're looking at. After a `gh auth login` command to get me auth'd, it was able to create the repo and push the code.

The repo looked great, but I felt something more was missing: visuals.


## NEXT PROMPT: update README with screenshots
Update the top-level README to include images of the application running. The app-startup.png file should go first, showing users how the app looks when you start the app. The app-running.png file shows what the app looks like when users have selected PDF files when running the app.

### Results
Uploading the images with that prompt didn't have any effect... it didn't seem to notice my uploads. I copied the files directly into the top-level folder then requested the `README` be updated and all 3 files (including the images) be committed to GitHub.

I followed up by manually editing `HISTORY.md` with these last few steps, and this is what you're looking at now. Bigger steps to take next are to get this thing running on GCP Cloud Run and testing the CLI.

Some of the files did have issues in the editor. I attempted to fix them which led to other problems and got stuck on Tailwind v3 vs. v4 incompatibilities. The solution was to roll back to v3 for now. Before getting to the next steps, I asked it to review all the `README` files because I didn't like the `frontend` one, which sounded like a generic template.


## NEXT PROMPT: cleanup the `README`s
> Scan all of the README files at the top-level, frontend, and backend to ensure they're descriptive of the respective content and improve them if possible.


### Results
After looking over the `README` files, it came up with:

_Here’s an analysis and improvement plan for your README files:_

- Add a summary and “Demo” section to the top-level README.
- Replace the frontend README with a project-specific one.
- Add a “Quick Start” to the backend README.

I accepted the changes and had Cursor push the latest upstream.


### Additional follow-up: CLI
The next day I decided to try the CLI. While the merge feature worked out-of-the-box, the delete feature had a bug where it could not complete the request. As a seasoned Python developer, it didn't take long to find the issue. But would it be challenging for Cursor? Not really. My prompt was: 

> There's a problem with the CLI. When running the CLI to delete pages from a PDF, I get this error: `❌ Error: Error deleting pages: seek of closed file`.

As the error indicates, the code is trying to access the file after it has been closed, making you realize that a huge chunk of code should be inside the `with` block. Cursor came to the same conclusion (and made the fix):

> I found the issue! The problem is in the `delete_pages` method. The file is being closed after reading the PDF, but then the code tries to access `pdf.pages[i]` later, which causes the "seek of closed file" error.


## NEXT PROMPT: change cloud deployments to return merged or modified PDF via HTTP instead of saving locally
> Taking a look at deploying the web app being to Google Cloud Run, some functionality needs to be changed to make it work successfully. When running both servers locally, it's not an issue to save the merged or modified PDFs to the local filesystem, but in the cloud, this is not the desired behavior because users want the merged or modified file returned to them and not stored on Google servers. Alter both the frontend and backend so that if running locally, the files are saved locally as they are now, but if deployed to Cloud Run, for the resulting file to be returned to the user via the HTTP response.

### Results
Cursor responded positively and came up with a plan and even provided an outline:

_This is a great and common requirement for cloud deployments! Here’s a concise plan and the changes you’ll need:_

1. **Backend (FastAPI)**
- **Current:** Saves merged/modified PDFs to disk, then returns or references them.
- **Cloud Run Desired:** Return the PDF file directly in the HTTP response (as a download), and do not save to disk.
**Local:** Continue saving to disk for convenience.
**How to detect environment:**
- Use an environment variable, e.g., `CLOUD_RUN` (set to `"true"` in Cloud Run).
**Backend logic:**
- If `CLOUD_RUN` is set, return the PDF as a streaming response.
- If not, save to disk as before.

2. **Frontend**
- **Current:** Downloads the file from the backend response.
- **Change needed:** None, if the backend returns the file as a download (with correct headers), the frontend can handle it as before.

3. **CLI**
- No change needed unless you want to support cloud mode for CLI as well.

4. **Implementation Plan**
**Backend (FastAPI)**
- Add a check for `os.environ.get("CLOUD_RUN") == "true"`.
- If in cloud mode, use `StreamingResponse` to return the PDF directly.
- If not, save to disk as before.
**Frontend**
- No change needed if you already handle file downloads from the response.

This plan seemed reasonable, so I gave the okay for implementation and committed the code. However, upon reflection looking at the changes, it appears that the app was already returning a `StreamingResponse`, and my request made Cursor deliberately add explicit saving of the resulting to the local filesystem needlessly.

Because my browser immediately saved the file, I made the mistake of assuming _the app wrote the PDF to the local filesystem, not the browser_. I realized the error of my ways and asked Cursor to revert this change, in both the code as well as the cloud `DEPLOYMENT.md` file:

> Actually upon reflection, the original was already streaming the response and not saving locally as there's no need for the local versions to explicitly save the resulting PDF. Please revert the change adding that feature, and also remove the need for the CLOUD_RUN environment variable so a StreamingResponse is sent back in all cases. Basically revert the code back to the previous version.

_The backend code has been reverted to always return a `StreamingResponse` for merged and modified PDFs, regardless of environment. The logic for saving files locally and the `CLOUD_RUN` environment variable has been removed. The deployment documentation has also been updated to remove references to the environment variable._

I had Cursor revert the update and committed the changes. The next step would be to deploy this app to GCP.

## NEXT PROMPT: change cloud deployments to return merged or modified PDF via HTTP instead of saving locally
Before doing the cloud deployment, I wanted to ensure the app can be accessed on the standard port 80, so I made this request:

> I'd like to modify a few things for the frontend:
> 1. Instead of hardcoding the server to run on the default Vite port 5173, configure the app so that it starts on 5173 for local deployments but on port 80 for Google Cloud Run deployments. Make necessary updates to the frontend README and top-level DEPLOYMENT.md
> 2. In index.html, change the default Vite page title to "PDFtool: a basic PDF manipulation app"
> 3. Delete the public/vite.svg file using "git rm" instead of just deleting locally, and also remove the corresponding line in index.html. I'll add a favicon.ico file which React will use as a default instead. 

### Results
Cursor generally complied but felt it needed to import Node.js types when it get a linter error trying to access `process.env.PORT`. I thought it could be handled by adding `import process from 'node:process'`, but I guess not because it has to be done using "Vite's built-in port detection"(?). I'm new to Vite & React vs. pure Node CLIs, so what do I know?

I let Cursor run `npm install --save-dev @types/node --prefix frontend`, and no import of `process` was required in the code after that. (We'll see.) After _this_ change, the frontend service starts locally on Vite's default port 5173, and cloud deployments will set `PORT=80` and access the Cloud Run frontend service URL directly. I did not try the app to ensure these changes worked because there was something else on the backend that needed to be updated first.


## NEXT PROMPT: change backend to default to port 80 for cloud deployments
> Because Cloud Run defaults to port 80, we need to change how the frontend accesses the backend, as while port 8000 is reachable for local deployments, it won't work for Cloud Run where the frontend service can contact the backend directly using the Cloud Run service URL which is port 80 by default. Can we make this adjustment?

### Results
Cursor made the necessary adjustments to the codebase, including added a shared `config.ts` file to pull up the API URL -- I still have to add the Cloud Run service URLs to make everything work in the Cloud once deployed, meaning I have to deploy the service the first time to get the service URLs, then redeploy with those service URLs in the app files.